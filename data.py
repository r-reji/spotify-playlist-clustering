""" 
This file collects the data for all the tracks from most (Line 45) of of the playlists in my Spotify 
library using the Spotify API and stores it as a csv file for further analysis.

Note: This file can take a long time to run (<1.2 seconds per song with artificial delays) if you are guilty 
of having several thousands of songs in your library like me. If you end up running into API timeout issues 
it should be noted that parallel processing is unlikely help much since the Spotify API is the most likely 
bottleneck.

Note 2: A much more efficient method is to take advantage of multiple API keys - either by asking friends or 
setting up multiple accounts. This will allow you to run multiple instances of this script at the same time.

Note 3: At the time of writing there is an issue with the Spotify API that causes the SPI value to be 
returned as 0 for a significant number of tracks. This is a known issue and is being worked on by
Spotify. As a result, the 'popularity' values have not been used at any point for any analysis 
which mainly effects the visualisation of the clusters that can be made. This is something I will 
revisit in future to produce better representations of the data. (See clusters.py for more details.)

Author: r_reji

"""

from credentials import *
import spotipy
from spotipy.oauth2 import SpotifyOAuth
import numpy as np
import pandas as pd
import time
from requests.exceptions import ReadTimeout

""" 
The following variables are API keys needed to authenticate the Spotify 
API. They have been kept in a separate file for security
purposes. You can get these credentials from 
https://developer.spotify.com by setting up an account and creating an app.

username = ''
spotifyClientID = ''
spotifyClientSecret = ''

Note: the redirectURL below needs to be specified in the developer dashboard
"""

redirectURL = 'http://localhost/'

sp = spotipy.Spotify(auth_manager=SpotifyOAuth(client_id = spotifyClientID, client_secret = spotifyClientSecret, redirect_uri = redirectURL, scope = 'user-library-read playlist-read-private', requests_timeout = 10))

playlists = sp.user_playlists(username)
playlistIDs = [item['uri'] for item in playlists['items']]

"""
Remove the playlists that I don't want to be included - they are either far too large in size (>1000 songs) 
or I do not want included in the dataset. 
"""

playlistIDs.remove(ignore1)
playlistIDs.remove(ignore2)
playlistIDs.remove(ignore3)
playlistIDs.remove(ignore4)
playlistIDs.remove(ignore5)
playlistIDs.remove(ignore6)

""" 
def getPlaylistTracks(playlistID):
    for track in sp.playlist_tracks(playlistID)['items']:
        yield track['track']['uri']

A generator method (such as the one commented above) would have been ideal for generating 
track lists however user_playlist_tracks function is limited to 100 tracks regardless of the 
parameter limit. Many of the playlists in my library are well over 100 tracks in size.

This limit is stated in the spotipy documentation but is easily overlooked on first read - 
took some to figure out. Generally the spotipy methods return paginated results so require a 
better way to handle this. 

Note: A slightly less elegant method would be to introduce an offset in the playlist_tracks() 
method - this introduces a host of new problems such as repeated offsetting until you 
exhaust the playlist. 

Note 2: If you are dealing with a large number of smaller playlists (<= 100 in track length) 
in your library, it will be much more efficient to use the generator shown above.
"""

def getPlaylistTracks(username, playlistID):
    results = sp.user_playlist_tracks(username, playlistID)
    tracks = results['items']
    while results['next']:
        results = sp.next(results)
        tracks.extend(results['items'])
    return tracks

tracks = [track for trackList in map(getPlaylistTracks, [username]*len(playlistIDs), playlistIDs) for track in trackList]

""" 
For each track in the list of tracks, extract the following features:

- Track ID
- Track URI
- Track Name
- Artist Name
- Duration
- Popularity

Want to also extract audio features for each track. These metrics are described in the 
Spotify developer documentation and are generated by Spotify's machine learning algorithms 
for each track. The metrics are as follows:

- Mood: Danceability, Valency, Energy, Tempo
- Properties: Loudness, Speechiness, Instrumentalness
- Context: Liveness, Acousticness

Among many others which I have not included in this dataset.
"""

trackData = {}
testData = {}
def getTrackData(trackList):
    startTime = time.time()
    ctrTrack = 0
    
    for track in trackList:
        ctrTrack += 1
        trackData[str(ctrTrack)] = {}
        trackData[str(ctrTrack)]['trackName'] = track['track']['name']
        trackData[str(ctrTrack)]['artistName'] = track['track']['artists'][0]['name']
        trackData[str(ctrTrack)]['trackID'] = track['track']['id']
        trackData[str(ctrTrack)]['trackURI'] = track['track']['uri']     
        trackData[str(ctrTrack)]['duration (min)'] = round(track['track']['duration_ms']*0.001/60, 2)
        trackData[str(ctrTrack)]['popularity'] = sp.track(tracks[ctrTrack-1]['track']['uri'])['popularity']
        trackData[str(ctrTrack)]['danceability'] = sp.audio_features(track['track']['id'])[0]['danceability']
        trackData[str(ctrTrack)]['energy'] = sp.audio_features(track['track']['id'])[0]['energy']
        trackData[str(ctrTrack)]['key'] = sp.audio_features(track['track']['id'])[0]['key']
        trackData[str(ctrTrack)]['loudness'] = sp.audio_features(track['track']['id'])[0]['loudness']
        trackData[str(ctrTrack)]['speechiness'] = sp.audio_features(track['track']['id'])[0]['speechiness']
        trackData[str(ctrTrack)]['acousticness'] = sp.audio_features(track['track']['id'])[0]['acousticness']
        trackData[str(ctrTrack)]['instrumentalness'] = sp.audio_features(track['track']['id'])[0]['instrumentalness']
        trackData[str(ctrTrack)]['liveness'] = sp.audio_features(track['track']['id'])[0]['liveness']
        trackData[str(ctrTrack)]['valence'] = sp.audio_features(track['track']['id'])[0]['valence']    
        trackData[str(ctrTrack)]['tempo'] = sp.audio_features(track['track']['id'])[0]['tempo']     
        
        if ctrTrack%10 == 0:
            time.sleep(np.random.uniform(0, 3))
            print(str(ctrTrack) + ' tracks processed')
            print('Elapsed time: {} seconds'.format(str(round(time.time() - startTime))))

""" 
Now extract all the track data for each track. Random delays have been added to avoid sending 
too many requests to the API at once and getting a timeout error - this is not strictly necessary and you can 
play around with the timings for slightly better performance.Then convert the trackData dictionary into a 
pandas dataframe and save it as a csv file.
"""

getTrackData(tracks)
dfTrackData = pd.DataFrame.from_dict(trackData, orient = 'index')
dfTrackData.to_csv(filePath)